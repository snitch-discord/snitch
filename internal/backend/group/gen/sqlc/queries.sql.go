// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package sqlc

import (
	"context"
)

const addServer = `-- name: AddServer :exec
INSERT INTO servers (
    server_id
) VALUES (?)
`

func (q *Queries) AddServer(ctx context.Context, serverID string) error {
	_, err := q.exec(ctx, q.addServerStmt, addServer, serverID)
	return err
}

const addUser = `-- name: AddUser :exec
INSERT OR IGNORE INTO users (
    user_id
) VALUES (?)
`

func (q *Queries) AddUser(ctx context.Context, userID string) error {
	_, err := q.exec(ctx, q.addUserStmt, addUser, userID)
	return err
}

const createReport = `-- name: CreateReport :one
INSERT INTO reports (
    report_text,
    reporter_id, 
    reported_user_id,
    origin_server_id
) values (?, ?, ?, ?)
RETURNING report_id
`

type CreateReportParams struct {
	ReportText     string `json:"report_text"`
	ReporterID     string `json:"reporter_id"`
	ReportedUserID string `json:"reported_user_id"`
	OriginServerID string `json:"origin_server_id"`
}

func (q *Queries) CreateReport(ctx context.Context, arg CreateReportParams) (string, error) {
	row := q.queryRow(ctx, q.createReportStmt, createReport,
		arg.ReportText,
		arg.ReporterID,
		arg.ReportedUserID,
		arg.OriginServerID,
	)
	var report_id string
	err := row.Scan(&report_id)
	return report_id, err
}

const createReportTable = `-- name: CreateReportTable :exec
CREATE TABLE IF NOT EXISTS reports (
    report_id TEXT PRIMARY KEY,
    report_text TEXT NOT NULL,
    reporter_id TEXT NOT NULL REFERENCES users(user_id),
    reported_user_id TEXT NOT NULL REFERENCES users(user_id),
    origin_server_id TEXT NOT NULL REFERENCES servers(server_id)
) STRICT
`

func (q *Queries) CreateReportTable(ctx context.Context) error {
	_, err := q.exec(ctx, q.createReportTableStmt, createReportTable)
	return err
}

const createServerTable = `-- name: CreateServerTable :exec
CREATE TABLE IF NOT EXISTS servers (
    server_id TEXT PRIMARY KEY
) STRICT
`

func (q *Queries) CreateServerTable(ctx context.Context) error {
	_, err := q.exec(ctx, q.createServerTableStmt, createServerTable)
	return err
}

const createUserHistory = `-- name: CreateUserHistory :one
INSERT INTO user_history (
    history_id,
    user_id,
    username,
    global_name,
    changed_at
) VALUES (?, ?, ?, ?, ?)
RETURNING history_id, user_id, username, global_name, changed_at
`

type CreateUserHistoryParams struct {
	HistoryID  string `json:"history_id"`
	UserID     string `json:"user_id"`
	Username   string `json:"username"`
	GlobalName string `json:"global_name"`
	ChangedAt  string `json:"changed_at"`
}

func (q *Queries) CreateUserHistory(ctx context.Context, arg CreateUserHistoryParams) (UserHistory, error) {
	row := q.queryRow(ctx, q.createUserHistoryStmt, createUserHistory,
		arg.HistoryID,
		arg.UserID,
		arg.Username,
		arg.GlobalName,
		arg.ChangedAt,
	)
	var i UserHistory
	err := row.Scan(
		&i.HistoryID,
		&i.UserID,
		&i.Username,
		&i.GlobalName,
		&i.ChangedAt,
	)
	return i, err
}

const createUserHistoryTable = `-- name: CreateUserHistoryTable :exec
CREATE TABLE IF NOT EXISTS user_history (
    history_id TEXT PRIMARY KEY,
    user_id TEXT NOT NULL,
    username TEXT NOT NULL,
    global_name TEXT,
    changed_at TEXT NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
) STRICT
`

func (q *Queries) CreateUserHistoryTable(ctx context.Context) error {
	_, err := q.exec(ctx, q.createUserHistoryTableStmt, createUserHistoryTable)
	return err
}

const createUserTable = `-- name: CreateUserTable :exec
CREATE TABLE IF NOT EXISTS users (
    user_id TEXT PRIMARY KEY
) STRICT
`

func (q *Queries) CreateUserTable(ctx context.Context) error {
	_, err := q.exec(ctx, q.createUserTableStmt, createUserTable)
	return err
}

const deleteReport = `-- name: DeleteReport :one
DELETE FROM reports
WHERE report_id = ?
RETURNING report_id
`

func (q *Queries) DeleteReport(ctx context.Context, reportID string) (string, error) {
	row := q.queryRow(ctx, q.deleteReportStmt, deleteReport, reportID)
	var report_id string
	err := row.Scan(&report_id)
	return report_id, err
}

const getAllReports = `-- name: GetAllReports :many
SELECT 
    report_text,
    reporter_id,
    reported_user_id,
    origin_server_id
FROM reports
`

type GetAllReportsRow struct {
	ReportText     string `json:"report_text"`
	ReporterID     string `json:"reporter_id"`
	ReportedUserID string `json:"reported_user_id"`
	OriginServerID string `json:"origin_server_id"`
}

func (q *Queries) GetAllReports(ctx context.Context) ([]GetAllReportsRow, error) {
	rows, err := q.query(ctx, q.getAllReportsStmt, getAllReports)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllReportsRow
	for rows.Next() {
		var i GetAllReportsRow
		if err := rows.Scan(
			&i.ReportText,
			&i.ReporterID,
			&i.ReportedUserID,
			&i.OriginServerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT user_id FROM users
WHERE user_id = ?
`

func (q *Queries) GetUser(ctx context.Context, userID string) (string, error) {
	row := q.queryRow(ctx, q.getUserStmt, getUser, userID)
	var user_id string
	err := row.Scan(&user_id)
	return user_id, err
}

const getUserHistory = `-- name: GetUserHistory :many
SELECT history_id, user_id, username, global_name, changed_at FROM user_history
WHERE user_id = ?
ORDER BY changed_at DESC
`

func (q *Queries) GetUserHistory(ctx context.Context, userID string) ([]UserHistory, error) {
	rows, err := q.query(ctx, q.getUserHistoryStmt, getUserHistory, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserHistory
	for rows.Next() {
		var i UserHistory
		if err := rows.Scan(
			&i.HistoryID,
			&i.UserID,
			&i.Username,
			&i.GlobalName,
			&i.ChangedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
