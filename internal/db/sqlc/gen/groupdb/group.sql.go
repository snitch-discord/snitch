// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: group.sql

package groupdb

import (
	"context"
	"database/sql"
)

const createReport = `-- name: CreateReport :one
INSERT INTO reports (report_text, reporter_id, reported_user_id, origin_server_id) 
VALUES (?, ?, ?, ?) RETURNING report_id
`

type CreateReportParams struct {
	ReportText     string `json:"report_text"`
	ReporterID     string `json:"reporter_id"`
	ReportedUserID string `json:"reported_user_id"`
	OriginServerID string `json:"origin_server_id"`
}

func (q *Queries) CreateReport(ctx context.Context, arg CreateReportParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createReport,
		arg.ReportText,
		arg.ReporterID,
		arg.ReportedUserID,
		arg.OriginServerID,
	)
	var report_id int64
	err := row.Scan(&report_id)
	return report_id, err
}

const createUserHistory = `-- name: CreateUserHistory :one
INSERT INTO user_history (user_id, server_id, action, reason, evidence_url) 
VALUES (?, ?, ?, ?, ?) RETURNING history_id
`

type CreateUserHistoryParams struct {
	UserID      string         `json:"user_id"`
	ServerID    string         `json:"server_id"`
	Action      string         `json:"action"`
	Reason      sql.NullString `json:"reason"`
	EvidenceUrl sql.NullString `json:"evidence_url"`
}

// User history queries
func (q *Queries) CreateUserHistory(ctx context.Context, arg CreateUserHistoryParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createUserHistory,
		arg.UserID,
		arg.ServerID,
		arg.Action,
		arg.Reason,
		arg.EvidenceUrl,
	)
	var history_id int64
	err := row.Scan(&history_id)
	return history_id, err
}

const deleteReport = `-- name: DeleteReport :execrows
DELETE FROM reports WHERE report_id = ?
`

func (q *Queries) DeleteReport(ctx context.Context, reportID int64) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteReport, reportID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const ensureServerExists = `-- name: EnsureServerExists :exec
INSERT OR IGNORE INTO servers (server_id) VALUES (?)
`

func (q *Queries) EnsureServerExists(ctx context.Context, serverID string) error {
	_, err := q.db.ExecContext(ctx, ensureServerExists, serverID)
	return err
}

const ensureUserExists = `-- name: EnsureUserExists :exec

INSERT OR IGNORE INTO users (user_id) VALUES (?)
`

// Group database queries (reports and users)
func (q *Queries) EnsureUserExists(ctx context.Context, userID string) error {
	_, err := q.db.ExecContext(ctx, ensureUserExists, userID)
	return err
}

const getReport = `-- name: GetReport :one
SELECT report_id, report_text, reporter_id, reported_user_id, origin_server_id, created_at 
FROM reports WHERE report_id = ?
`

func (q *Queries) GetReport(ctx context.Context, reportID int64) (Report, error) {
	row := q.db.QueryRowContext(ctx, getReport, reportID)
	var i Report
	err := row.Scan(
		&i.ReportID,
		&i.ReportText,
		&i.ReporterID,
		&i.ReportedUserID,
		&i.OriginServerID,
		&i.CreatedAt,
	)
	return i, err
}

const getUserHistory = `-- name: GetUserHistory :many
SELECT history_id, user_id, server_id, action, reason, evidence_url, created_at 
FROM user_history 
WHERE user_id = ? 
ORDER BY created_at DESC
`

func (q *Queries) GetUserHistory(ctx context.Context, userID string) ([]UserHistory, error) {
	rows, err := q.db.QueryContext(ctx, getUserHistory, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserHistory{}
	for rows.Next() {
		var i UserHistory
		if err := rows.Scan(
			&i.HistoryID,
			&i.UserID,
			&i.ServerID,
			&i.Action,
			&i.Reason,
			&i.EvidenceUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReports = `-- name: ListReports :many
SELECT report_id, report_text, reporter_id, reported_user_id, origin_server_id, created_at 
FROM reports
ORDER BY created_at DESC
`

func (q *Queries) ListReports(ctx context.Context) ([]Report, error) {
	rows, err := q.db.QueryContext(ctx, listReports)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Report{}
	for rows.Next() {
		var i Report
		if err := rows.Scan(
			&i.ReportID,
			&i.ReportText,
			&i.ReporterID,
			&i.ReportedUserID,
			&i.OriginServerID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReportsByUser = `-- name: ListReportsByUser :many
SELECT report_id, report_text, reporter_id, reported_user_id, origin_server_id, created_at 
FROM reports 
WHERE reported_user_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListReportsByUser(ctx context.Context, reportedUserID string) ([]Report, error) {
	rows, err := q.db.QueryContext(ctx, listReportsByUser, reportedUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Report{}
	for rows.Next() {
		var i Report
		if err := rows.Scan(
			&i.ReportID,
			&i.ReportText,
			&i.ReporterID,
			&i.ReportedUserID,
			&i.OriginServerID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
